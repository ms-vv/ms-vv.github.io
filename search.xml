<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL常用符号</title>
      <link href="/blog/MySQL%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
      <url>/blog/MySQL%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h1><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><table><thead><tr><th>注释符</th><th>说明</th></tr></thead><tbody><tr><td>#(%23)</td><td>单行注释<br>在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由，所以测试一般用URL编码后的%23</td></tr><tr><td>–<br>– -<br>&#x3D;–+</td><td>单行注释<br>注意–后还有一个空格；其中+号会被URL解码为空格</td></tr><tr><td>&#x2F;**&#x2F;</td><td>多行(内联)注释<br>一般用于绕过WAF、代替空格等</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与，同and</td></tr><tr><td>||</td><td>或，同or</td></tr><tr><td>！</td><td>非，同not</td></tr><tr><td>^</td><td>异或，同xor</td></tr><tr><td>\</td><td>转义符</td></tr><tr><td>~</td><td>一元比特反转</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>+</td><td>加，URL解码后可代替空格</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>&#x2F;或div</td><td>除法</td></tr><tr><td>%或mod</td><td>取余</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;,!&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>between</td><td>在两值之间</td></tr><tr><td>not between</td><td>不在两值之间</td></tr><tr><td>in</td><td>在集合中</td></tr><tr><td>not in</td><td>不在集合中</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>严格比较两个NULL值是否相等</td></tr><tr><td>like</td><td>模糊匹配</td></tr><tr><td>regexp或rlike</td><td>正则式匹配</td></tr><tr><td>is null</td><td>为空</td></tr><tr><td>is not null</td><td>不为空</td></tr></tbody></table><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>所有全局变量可通过如下语句查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables;</span><br><span class="line"><span class="keyword">show</span> variaves;</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>@@version</td><td>返回版本信息</td></tr><tr><td>@@global.version</td><td>同@@version</td></tr><tr><td>@@hostname</td><td>返回安装计算机名称</td></tr><tr><td>@@basedir</td><td>返回mysql绝对路径</td></tr><tr><td>@@datadir</td><td>数据路径</td></tr></tbody></table><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="数据库信息"><a href="#数据库信息" class="headerlink" title="数据库信息"></a>数据库信息</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>user()</td><td>获取当前操作句柄的用户名，同session_user()、current_user(),有时也用system_user()</td></tr><tr><td>databse()</td><td>获取当前选择数据库名，同schema()</td></tr><tr><td>version()</td><td>获取当前版本信息</td></tr></tbody></table><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ascii(str)</td><td>返回字符串第一个字符的ascii值</td></tr><tr><td>ord(str)</td><td>同ascii(str)</td></tr><tr><td>hex(n_s)</td><td>参数为字符串时，返回n or s的16进制字符串形式；为数字时，返回其16进制数形式</td></tr><tr><td>unhex(str)</td><td>hex(str)的逆向函数将参数中的每一对16进制数字都转换为10进制数字，然后再转换成ascii码所对应的字符</td></tr><tr><td>bin(n)</td><td>返回十进制数值n的二进制数值的字符串表现形式n时一个bigint型数值，作用相当于conv(n,10,2)</td></tr><tr><td>oct(n)</td><td>返回十进制n的八进制数值的字符串表现形式</td></tr><tr><td>conv(n,f,t)</td><td>将数值型参数n由初始进制f转换为目标进制t的形式并返回</td></tr><tr><td>char(n,…)</td><td>将每一个参数n都解释为整数，返回由这些整数再ascii码中对应字符所组成的字符串</td></tr></tbody></table><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>substr(str,n_start,n_length)</td><td>对指定字符串进行截取，为substring的简单版<br>str:截取的字符串<br>n_start:截取起始位置(mysql中start从1开始)<br>n_length:截取长度</td></tr><tr><td>substring(str,start)<br>substring(str,start,len)<br>substring(str from start)<br>substring(str from strat for len)</td><td>对指定字符串进行截取，有多种形式<br>str:截取的字符串<br>start:截取起始位置(mysql中start从1开始)<br>len:截取长度</td></tr><tr><td>mid(str,pos,len)</td><td>同substring(str,pos,len)</td></tr><tr><td>right(str,len)</td><td>对指定字符串从最右边截取指定长度</td></tr><tr><td>left(str,len)</td><td>对指定字符串从最左边截取指定长度</td></tr><tr><td>rpad(str,len,padstr)</td><td>在str右方补齐len位的字符串padstr，返回新字符串如果str长度大于len，则返回的长度将缩减到le所指定的长度</td></tr><tr><td>lpad(str,len,padstr)</td><td>与rpad显示，在str左边补齐</td></tr><tr><td>insert(str,pos,len,newstr)</td><td>在原始字符串str中，将自左第pos位开始，长度为len个字符的字符串替换为新字符串newstr，然后返回经过替换后的字符串。insert(str,len,1,0x0)可当作截取函数</td></tr></tbody></table><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>concat(str1,str2)</td><td>函数用于将多个字符串合并为一个字符串</td></tr><tr><td>concat_ws（sep,str1,str2）</td><td>和concat函数类似，通过分隔符sep连接到一起</td></tr><tr><td>group_concat(…）</td><td>返回一个非字符串结果，该结果由分组中的值通过逗号连接组合而成</td></tr><tr><td>make_set(bits,str1,str2)</td><td>返回一个设定值(含子字符串分割字符串”,”字符)，在设置位的相应位字符串可用作布尔盲注，如:exp(make_set((length(database())&gt;8)+1,’1’,’710’))</td></tr></tbody></table><h2 id="数据匹配"><a href="#数据匹配" class="headerlink" title="数据匹配"></a>数据匹配</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D; statement</td><td>全匹配</td></tr><tr><td>like “statement”</td><td>匹配数据,%代表任意内容</td></tr><tr><td>regexp “statement”</td><td>正则匹配数据</td></tr><tr><td>rliek “statement”</td><td>同regexp</td></tr></tbody></table><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>if(exp,state1,state2)</td><td>条件语句，exp为true，执行state1，否则执行state2</td></tr><tr><td>case…when exp then state1 else state2 end</td><td>同if，…可直接省略</td></tr><tr><td>nullif(expr1,expr2)</td><td>若expr1与expr2相同，则返回expr1，否则返回NULL</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>sleep(n)</td><td>休眠n秒</td></tr><tr><td>benchmark(count,expr)</td><td>将表达式expr重复运行count次(消耗cpu)，可以达到sleep的效果</td></tr><tr><td>order by</td><td>用于对结果集进行排序，默认按照升序进行排序</td></tr><tr><td>exists(sql)</td><td>判断sql语句执行后是否由结果；若存在的话返回结果为1，不存在的话返回结果为0</td></tr><tr><td>limit m,n</td><td>查询结果从m开始取n个</td></tr><tr><td>length(str)</td><td>返回字符串的长度</td></tr><tr><td>load_file(filepath)</td><td>读取文件内容，可以将文件名转换成ascii码或者十六进制形式；secure_file_priv默认情况下为null不允许读文件<br>ascii码需要用char()函数，char(96,97)<br>十六进制前面要加上0x<br>读取内容不显示的情况下，可以用hex()函数:hex(load_file())</td></tr><tr><td>PI()</td><td>返回PI的具体数值</td></tr><tr><td>locate(substr,str,[pos])</td><td>返回子字符串第一次出现的位置</td></tr><tr><td>position(substr IN str)</td><td>等同于 locate()</td></tr><tr><td>lower(str)</td><td>将字符串大写字母转换为小写字母同:lcase(str)</td></tr><tr><td>upper(str)</td><td>将字符串小写字母转换为大写字母同:ucase(str)</td></tr><tr><td>elt(n,str1,str2,…)</td><td>与make_set(bit,str1,str2…)类似，根据N返回参数值</td></tr><tr><td>charset(str)</td><td>返回字符串所使用的字符集</td></tr><tr><td>decode(cr_str,pass_str)</td><td>使用pass_str作为密码，解密加密字符串cr_str。加密函数:encode(str,pass_str)</td></tr></tbody></table><h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><table><thead><tr><th>说明</th><th>语句</th></tr></thead><tbody><tr><td>基础信息</td><td>获取数据库版本信息<br>select version();<br>select @@innodb_version;<br>获取当前用户<br>select user();<br>获取当前数据库<br>select database();<br>数据路径<br>select @@datadir;</td></tr><tr><td>获取所有数据库</td><td>select shema_name from information_schema.schemata;</td></tr><tr><td>获取所有用户</td><td>查看表结构<br>desc mysql.user<br>获取所有用户信息<br>select * from mysql.user</td></tr><tr><td>获取数据库表名</td><td>desc information_schema.tables;<br><br>select table_name from information_schema.tables where table_schema &#x3D; database();<br><br>select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database();</td></tr><tr><td>获取当前数据库的某表的列名</td><td>select column_name from information_schema.columns where table_name &#x3D; ‘表名’;<br>select group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘表名’;</td></tr><tr><td>获取当前数据库中某列的值</td><td>select id ,username,password from users;</td></tr><tr><td>查询DBA账户(一般为root)</td><td>select host, user from mysql.user where super_priv &#x3D; ‘y’;</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入数据库识别</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>确认注入点后，我们需要识别后端所使用的数据库，因为不同的数据库注入的方式不一样，后期利用手法和条件也不一样。</p><div class="note purple no-icon flat"><p>核心就是利用数据库<strong>特有的一些语法或者时函数</strong>来判断即可，毕竟要满足该数据库的语法后SQL语句才能正常执行；下面的例子不全面，只是给大家提供一个思路，最明显的就是<strong>休眠函数</strong></p></div><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>sleep函数</td><td>1’-sleep(1)&#x3D;0 limit 1 –</td></tr><tr><td>banchmark函数</td><td>1’-banchmark(5000000,encode(‘Slow Down’,’by 5 seconds’))&#x3D;0 limit 1 –</td></tr><tr><td>字符串连接</td><td>id&#x3D;’ ‘mysql’ –<br>id&#x3D;’ and concat(‘some’,’string’)</td></tr><tr><td>版本信息</td><td>select @@version<br>select version()</td></tr><tr><td>错误消息</td><td>id&#x3D;’<br></td></tr><tr><td>特有函数</td><td>select connection_id()<br>select last_insert_id<br>select row_count()</td></tr></tbody></table><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘oracle’ –a&#96;</td></tr><tr><td>默认表</td><td>id&#x3D;’union select 1 from v$version – <br>select banner from v$version<br>select banner from v$version where rownum&#x3D;1</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr></tbody></table><h1 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>waitfor函数</td><td>‘;waitfor delay ‘00:00:10’; –</td></tr><tr><td>堆叠查询默认变量</td><td>sql’;select @@servername –</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr><tr><td>错误消息（id整数，@@servername转换错误）</td><td>id&#x3D;@@servername<br>id&#x3D;0&#x2F;@@servername</td></tr><tr><td>常量</td><td>@@pack_received<br>@@rowcount</td></tr></tbody></table><h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘postgresql’ –a</td></tr><tr><td>休眠函数</td><td>id&#x3D;’ and (select pg_sleep_for(‘5 sec’)) is null – a</td></tr></tbody></table><h1 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h1><table><thead><tr><th>方法</th><th>数据库</th></tr></thead><tbody><tr><td>常用搭配</td><td>asp &#x3D;&gt; mssql、access<br>aspx &#x3D;&gt; mssql<br>php &#x3D;&gt; mysql\postgresql<br>java &#x3D;&gt; mysql、oracle、mssql</td></tr><tr><td>默认端口</td><td>oracle &#x3D;&gt; 1521<br>mssql &#x3D;&gt; 1433<br>mysql &#x3D;&gt; 3306<br>postgresql &#x3D;&gt; 5432</td></tr><tr><td>数据库特有函数</td><td>pg_sleep() &#x3D;&gt; postgresql<br>benchmark &#x3D;&gt; mysql<br>waitfor delay &#x3D;&gt; mssql<br>dbms_pipe.receive_message() &#x3D;&gt; oracle</td></tr><tr><td>特殊符号</td><td>；&#x3D;&gt; postgresql、mssql默认可堆叠查询<br># &#x3D;&gt; MySQL注释符</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入点检测</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>挖掘SQL注入漏洞的第一步，就是发现SQL注入漏洞，只有发现了注入点才能够继续深入利用。</p><p>可以通过多种方式来检测是否存在注入，最简单的就是直接在参数后面加上<mark style="background: #FFB8EBA6;">‘</mark> 或者<mark style="background: #D2B3FFA6;">“</mark>等特殊字符让web应用程序抛出异常；但这种情况已经很少见了，比较好的方法是通过盲注来进行判断；</p><h1 id="注入点位置"><a href="#注入点位置" class="headerlink" title="注入点位置"></a>注入点位置</h1><p>所有和数据库有交互的地方均可能存在SQL注入，因此我们在分析数据包的时候， 可以关注一下哪些数据可能会和数据库交互，从而进行测试是否存在SQL注入漏洞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /?<span class="built_in">id</span>=homePage* HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.netspi.com*</span><br><span class="line">Connection: close</span><br><span class="line">Cache-Control: <span class="built_in">max</span>-age=<span class="number">0</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">62.0</span><span class="number">.3202</span><span class="number">.94</span> Safari/<span class="number">537.36</span>*</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=<span class="number">0.9</span></span><br><span class="line">X-Server-Name: PROD*</span><br><span class="line">Cookie: user=harold;*</span><br><span class="line">Content-<span class="type">Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=harold*&amp;email=harold@netspi.com*</span><br></pre></td></tr></table></figure><blockquote><p>如果传输的是json格式的数据，在使用双引号闭合时，记得使用\来防止破坏json数据结构，如下，其他特殊结构数据类似<br>{“username”:”test&quot;“}</p></blockquote><h1 id="注入检测"><a href="#注入检测" class="headerlink" title="注入检测"></a>注入检测</h1><p>检测是否存在注入一般通过两种方式来判断：</p><ol><li>输入特殊字符是否抛出相关异常</li><li>输入一些语句运行是否达到我们预期的结果（返回内容、响应时间等）</li></ol><table><thead><tr><th>类型</th><th>语句和结果</th></tr></thead><tbody><tr><td>特殊字符</td><td>id&#x3D;’)”)</td></tr><tr><td>逻辑算数测试</td><td>id&#x3D;’ and 2*3&#x3D;6 – true<br>id&#x3D;’ and 2*3&#x3D;5 – false<br>id&#x3D;2*3 是否返回id&#x3D;6内容<br>id&#x3D;1&#x2F;1 true<br>id&#x3D;1&#x2F;0 false</td></tr><tr><td>返回延时</td><td>id&#x3D; ‘ and sleep(5) 延迟5秒或更久</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SQL注入是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而执行，因此遭到破坏或是入侵。</p><h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验（类型、长度、业务参数合法性、敏感字符等），同时没有对用户输入数据进行有效地特殊字符过滤，使得用户的输入直接带入数据库进行执行，超出了SQL语句原来设计的预期结果，导致了SQL注入漏洞。</p><h1 id="注入举例"><a href="#注入举例" class="headerlink" title="注入举例"></a>注入举例</h1><p>以下代码为模拟web应用程序进行登录炒作。若登录成功返回success，失败则返回fail</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connection failed: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$username</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username = &#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$rs</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>,<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$rs</span>-&gt;<span class="title function_ invoke__">fetch_row</span>())&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用户名<mark class="hl-label blue">username</mark> 和密码<mark class="hl-label green">password</mark> 均来之用户的直接传入，无任何过滤，后直接拼接到SQL语句中。<br>正常用户登录时，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者尝试登录，输入用户名<mark class="hl-label pink">admin’ or '1'='1</mark> ,输入密码123，因为是直接拼接，所以构造出的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>此时因为sql语句中存在or ‘1’&#x3D;‘1’，所以永为真，将会查询出所有的结果，也就会登录成功返回success。(也就是万能密码)</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>SQL注入漏洞可能出现在一切数据库交互的地方，常见举例如下：</strong></p><blockquote><p>简而言之：所有和数据库交互的点均可能存在SQL注入</p></blockquote><table><thead><tr><th align="left">关键字</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">增</td><td align="left">注册新用户、创建订单、添加文章……</td></tr><tr><td align="left">删</td><td align="left">删除用户、删除订单……</td></tr><tr><td align="left">改</td><td align="left">修改订单、更新用户信息……</td></tr><tr><td align="left">查</td><td align="left">查询信息、筛选订单、搜索文章……</td></tr></tbody></table><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><ol><li>获取数据库访问权限，甚至获得DBA权限，从而获取数据库中所有数据，造成信息泄露；（可获取数据）</li><li>对数据库进行增删改操作，例如删除数据库中重要数据库的表（可进行增删改操作）</li><li>通过构造特殊的数据库语句，可操作数据库进入后台或插入木马，以获取整个网站和数据库的控制权限，篡改网页，发布不良信息等。（可获取网站权限）</li><li>获取服务器最高权限，远程控制服务器，甚至导致局域网被入侵；（可获取服务器权限）</li></ol><h1 id="通用修复建议"><a href="#通用修复建议" class="headerlink" title="通用修复建议"></a>通用修复建议</h1><h2 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h2><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><ol><li>严格控制输入数据的类型；如通过id获取用户信息时，仅允许传入的id为整行</li><li>严格控制输入数据的长度；如限制用户名长度应小于20</li><li>输入合法性判断；禁止出现一些特殊字符或关键词<ul><li>‘ , “ , \ , &lt; , &gt; , &amp; ,* , ; , # , select , from , where, sub , if , union , sleep , and , or 等</li></ul></li><li>对所有可能的输入点进行判断检查，如UA、IP、Cookie等</li></ol><h3 id="预编译SQL语句（参数化查询）"><a href="#预编译SQL语句（参数化查询）" class="headerlink" title="预编译SQL语句（参数化查询）"></a>预编译SQL语句（参数化查询）</h3><p>参数化查询是一种查询类型，其中占位符用于填充参数，参数值在执行时提供。原理是采用了预编译的方法，先将SQL语句中可被用户控制的参数集进行编译，生成对应的变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值过程中会对传入的参数进行强制类型检查和安全检查。</p><p>所有与数据库交互的业务接口均采用参数化查询，参数化的语句使用参数而不是将用户输入变量直接嵌入到SQL语句中，参数化查询是防御SQL注入的最佳方法，比如：Java中的<mark class="hl-label purple">PreparedStatement</mark> ，PHP中的<mark class="hl-label blue">PDO</mark> 等。</p><h2 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h2><h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><p>遵循最小化权限原则，严格限制网站用户的数据库操作权限，禁止将任何高权限账户（sa，dba，root等）用于应用程序数据库访问，从而最大限度的减少注入攻击对数据库的危害。</p><h3 id="禁用敏感函数"><a href="#禁用敏感函数" class="headerlink" title="禁用敏感函数"></a>禁用敏感函数</h3><p>防止攻击者通过SQL注入获取到除数据库外的其他更高权限，如系统权限等；<br>比如MSSQL中，拒绝用户访问敏感的系统存储过程，如xp_dirtree、xp_xmdshell等。</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>限制用户仅能够访问必须使用的数据库表。</p><h3 id="统一编码"><a href="#统一编码" class="headerlink" title="统一编码"></a>统一编码</h3><p>网站与数据层的编码统一，建议全部使用UTF-8编码，避免上下层编码不一致导致一些过滤模型被绕过，比如宽字节注入等。</p><h2 id="其他层面"><a href="#其他层面" class="headerlink" title="其他层面"></a>其他层面</h2><ol><li>网站应避免抛出SQL语句执行过程中的错误信息，如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断；</li><li>使用通用防注入系统，或部署WAF等。</li></ol><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><ol><li>在测试SQL注入的时候，一定要思考后端的SQL语句是如何构造的，只有判断除后端SQL语句的大致构造情况，才能知道我们可控注入点的位置，可能是<mark class="hl-label green">select sqli</mark> 、<mark class="hl-label pink">where id=</mark>  、<mark class="hl-label purple">order by sqli</mark> ，这样才好对症下药。</li></ol><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
